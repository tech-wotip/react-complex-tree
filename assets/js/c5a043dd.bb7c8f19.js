(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8386],{30876:function(e,t,n){"use strict";n.d(t,{Zo:function(){return l},kt:function(){return m}});var r=n(2784);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},l=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,l=d(e,["components","mdxType","originalType","parentName"]),p=c(n),m=o,f=p["".concat(s,".").concat(m)]||p[m]||u[m]||i;return n?r.createElement(f,a(a({ref:t},l),{},{components:n})):r.createElement(f,a({ref:t},l))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=p;var d={};for(var s in t)hasOwnProperty.call(t,s)&&(d[s]=t[s]);d.originalType=e,d.mdxType="string"==typeof e?e:o,a[1]=d;for(var c=2;c<i;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},74337:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return d},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return l},default:function(){return p}});var r=n(7560),o=n(98283),i=(n(2784),n(30876)),a=["components"],d={sidebar_position:2},s="Custom Data Provider",c={unversionedId:"guides/custom-data-provider",id:"guides/custom-data-provider",isDocsHomePage:!1,title:"Custom Data Provider",description:"When using an uncontrolled environment, you need to provide your data by supplying a data provider.",source:"@site/docs/guides/custom-data-provider.mdx",sourceDirName:"guides",slug:"/guides/custom-data-provider",permalink:"/docs/guides/custom-data-provider",editUrl:"https://github.com/lukasbach/react-complex-tree/edit/main/packages/docs/docs/guides/custom-data-provider.mdx",version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Uncontrolled Environment",permalink:"/docs/guides/uncontrolled-environment"},next:{title:"Controlled Environment",permalink:"/docs/guides/controlled-environment"}},l=[],u={toc:l};function p(e){var t=e.components,n=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"custom-data-provider"},"Custom Data Provider"),(0,i.kt)("p",null,"When using an uncontrolled environment, you need to provide your data by supplying a data provider.\nThis provider must implement the ",(0,i.kt)("a",{parentName:"p",href:"/docs/api/interfaces/TreeDataProvider"},"TreeDataProvider interface"),", i.e."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface TreeDataProvider<T = any> {\n  onDidChangeTreeData?: (listener: (changedItemIds: TreeItemIndex[]) => void) => Disposable;\n  getTreeItem: (itemId: TreeItemIndex) => Promise<TreeItem<T>>;\n  getTreeItems?: (itemIds: TreeItemIndex[]) => Promise<TreeItem[]>;\n  onRenameItem?: (item: TreeItem<T>, name: string) => Promise<void>;\n  onChangeItemChildren?: (itemId: TreeItemIndex, newChildren: TreeItemIndex[]) => Promise<void>;\n}\n")),(0,i.kt)("p",null,"At least the ",(0,i.kt)("inlineCode",{parentName:"p"},"getTreeItem")," method must be implemented, to declare how data can be made available\nto the tree structure. ",(0,i.kt)("inlineCode",{parentName:"p"},"getTreeItems")," allows you to make loading more efficient if multiple entries\nneed to be loaded at once. If you do not implement ",(0,i.kt)("inlineCode",{parentName:"p"},"getTreeItems"),", they are loaded sequentially\nusing ",(0,i.kt)("inlineCode",{parentName:"p"},"getTreeItem"),"."),(0,i.kt)("p",null,"The methods ",(0,i.kt)("inlineCode",{parentName:"p"},"onRenameItem")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"onChangeItemChildren")," allow you to declare how updates to the\ntree structure should be handled, i.e. by renaming an item or moving items from one parent to\nanother. You still need to enable this functionality in the environment by providing the respective\nflags. Look into the ",(0,i.kt)("a",{parentName:"p",href:"/docs/api/interfaces/treecapabilities"},"TreeCapabilities interface")," for more details\non the necessary flags."))}p.isMDXComponent=!0}}]);